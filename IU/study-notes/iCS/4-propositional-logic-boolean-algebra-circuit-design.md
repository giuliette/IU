## ALGORITHMS & FLOWCHARTS
**Algorithm**: A finite set of well-defined steps to solve a problem (complete a task)
**Flowchart**: A visual representation of an algorithm, using standardized symbols to depict steps.
  **Terminator** (Oval): Marks the start and end points.
  **Process** (Rectangle): Represents operations or instructions (e.g., calculations).
  **Decision** (Diamond): A point where the algorithm branches based on a condition.
  **Input/Output** (Parallelogram): Represents data being received or displayed.
  **Arrows**: Indicate flow and direction of the process.

## SIMPLE DATA STRUCTURES
**Array**: Fixed-size linear structure for storing elements of the same type.
**Stack**: Last In, First Out (LIFO) data structure.
**Queue**: First In, First Out (FIFO) structure.
**Linked List**: Collection of nodes where each node points to the next.
**Hash Table**: Uses hash functions for quick lookup (average O(1) time).
**Tree**: Hierarchical data structure (e.g., binary trees).
**Graph**: Set of nodes (vertices) connected by edges; may be directed or undirected.

## SEARCHING & SORTING
### Searching
**Linear Search**: Check each element one by one 
(O(n)).
**Binary Search**: Divide and conquer method on sorted lists 
(O(log n)).

### Sorting Algorithms
**Bubble Sort**: Repeatedly swapping elements next to each other 
(O(n²)).
**Insertion Sort**: Builds sorted array one element at a time 
(O(n²)).
**Merge Sort**: Divide and conquer, stable 
(O(n log n)).
**Quick Sort**: Divide and conquer with pivot 
(O(n log n) average).
**BogoBogo Sort** 

## QUALITY OF ALGORITHMS
**Big O Notation**: Describes the upper bound of time/space complexity (e.g., O(n), O(log n)).
in order (ordo in latin)
**Time Complexity**: How execution time grows with input size.
**Space Complexity**: How memory usage grows with input size.
**Efficiency Analysis**: Comparing algorithms based on runtime and resource usage.
**Scalability**: How well an algorithm handles growing input sizes.

## OTHER KEY CONCEPTS
**Recursion**: A function that calls itself; used in problems that can be broken down similarly.
**Dynamic Programming**: Optimization method for problems with overlapping subproblems.
**Graph Algorithms**:
  **DFS (Depth-First Search)**: Explores as far as possible along each branch.
  **BFS (Breadth-First Search)**: Explores neighbors level by level.
**E-A-T (Expertise, Authoritativeness, Trustworthiness)**: Evaluation criteria for algorithmic quality in user-facing apps like web search.